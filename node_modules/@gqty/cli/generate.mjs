import { SchemaUnionsKey, parseSchemaType } from 'gqty';
import * as graphql from 'graphql';
import { gqtyConfigPromise, defaultConfig } from './config.mjs';
import * as deps from './deps.js';
import { formatPrettier } from './prettier.mjs';

const {
  isEnumType,
  isInputObjectType,
  isInterfaceType,
  isNullableType,
  isObjectType,
  isScalarType,
  isUnionType,
  lexicographicSortSchema,
  parse,
  isSchema,
  assertSchema
} = graphql;
async function generate(schema, {
  preImport,
  scalarTypes,
  react,
  endpoint,
  enumsAsStrings,
  enumsAsConst,
  subscriptions,
  javascriptOutput,
  transformSchema
} = {}, { ignoreArgs } = {}) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const gqtyConfig = (await gqtyConfigPromise).config;
  const isJavascriptOutput = (_a = javascriptOutput != null ? javascriptOutput : gqtyConfig.javascriptOutput) != null ? _a : defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (gqtyConfig.enumsAsStrings) {
      console.warn(`"enumsAsStrings" is automatically set as "true" with "javascriptOutput" enabled.`);
    }
    enumsAsStrings = true;
  } else {
    enumsAsStrings != null ? enumsAsStrings : enumsAsStrings = (_b = gqtyConfig.enumsAsStrings) != null ? _b : false;
  }
  if (isJavascriptOutput) {
    if (gqtyConfig.enumsAsConst) {
      console.warn(`"enumsAsConst" is automatically set as "false" with "javascriptOutput" enabled.`);
    }
    enumsAsConst = false;
  }
  enumsAsConst != null ? enumsAsConst : enumsAsConst = (_c = gqtyConfig.enumsAsConst) != null ? _c : defaultConfig.enumsAsConst;
  scalarTypes || (scalarTypes = gqtyConfig.scalarTypes || defaultConfig.scalarTypes);
  endpoint || (endpoint = (_e = (_d = gqtyConfig.introspection) == null ? void 0 : _d.endpoint) != null ? _e : defaultConfig.introspection.endpoint);
  if (endpoint == null || !(endpoint.startsWith("http://") && endpoint.startsWith("https://"))) {
    endpoint = "/api/graphql";
  }
  react != null ? react : react = (_f = gqtyConfig.react) != null ? _f : defaultConfig.react;
  preImport != null ? preImport : preImport = (_g = gqtyConfig.preImport) != null ? _g : defaultConfig.preImport;
  subscriptions != null ? subscriptions : subscriptions = (_h = gqtyConfig.subscriptions) != null ? _h : defaultConfig.subscriptions;
  transformSchema != null ? transformSchema : transformSchema = gqtyConfig.transformSchema;
  const { format } = formatPrettier({
    parser: "typescript"
  });
  schema = lexicographicSortSchema(assertSchema(schema));
  if (transformSchema) {
    schema = await transformSchema(schema, graphql);
    if (!isSchema(schema)) {
      throw Error(`"transformSchema" returned an invalid GraphQL Schema!`);
    }
  }
  const codegenResultPromise = deps.codegen({
    schema: parse(deps.printSchemaWithDirectives(schema)),
    config: {},
    documents: [],
    filename: "gqty.generated.ts",
    pluginMap: {
      typescript: deps.typescriptPlugin
    },
    plugins: [
      {
        typescript: {
          onlyOperationTypes: true,
          declarationKind: "interface",
          addUnderscoreToArgsType: true,
          scalars: scalarTypes,
          namingConvention: "keep",
          enumsAsTypes: enumsAsStrings,
          enumsAsConst
        }
      }
    ]
  });
  const config = schema.toConfig();
  const scalarsEnumsHash = {};
  const enumsNames = [];
  const inputTypeNames = /* @__PURE__ */ new Set();
  const generatedSchema = {
    query: {},
    mutation: {},
    subscription: {}
  };
  const queryType = config.query;
  const mutationType = config.mutation;
  const subscriptionType = config.subscription;
  const descriptions = /* @__PURE__ */ new Map();
  const fieldsDescriptions = /* @__PURE__ */ new Map();
  const fieldsArgsDescriptions = /* @__PURE__ */ new Map();
  function addDescription(typeName) {
    var _a2, _b2, _c2;
    if (Array.isArray(typeName)) {
      const data = typeName[2] ? (_b2 = (_a2 = fieldsArgsDescriptions.get(typeName[0])) == null ? void 0 : _a2[typeName[1]]) == null ? void 0 : _b2[typeName[2]] : (_c2 = fieldsDescriptions.get(typeName[0])) == null ? void 0 : _c2[typeName[1]];
      let comment = "";
      if (data == null ? void 0 : data.description) {
        comment += "\n" + data.description.trim().split("\n").map((line) => "* " + line).join("\n");
      }
      if (data == null ? void 0 : data.deprecated) {
        comment += "\n* @deprecated " + data.deprecated.trim().replace(/\n/g, ". ").trim();
      }
      if (data == null ? void 0 : data.defaultValue) {
        comment += "\n* @defaultValue `" + data.defaultValue.trim() + "`";
      }
      return comment ? `/** ${comment} 
      */
` : "";
    } else {
      const desc = descriptions.get(typeName);
      return desc ? `/**
        ${desc.trim().split("\n").map((line) => "* " + line).join("\n")}
      */
` : "";
    }
  }
  const parseEnumType = (type) => {
    scalarsEnumsHash[type.name] = true;
    enumsNames.push(type.name);
    const values = type.getValues();
    const enumValuesDescriptions = {};
    for (const value of values) {
      if (value.deprecationReason || value.description) {
        enumValuesDescriptions[value.name] = {
          description: value.description,
          deprecated: value.deprecationReason
        };
      }
    }
    fieldsDescriptions.set(type.name, enumValuesDescriptions);
  };
  const parseScalarType = (type) => {
    scalarsEnumsHash[type.name] = true;
  };
  const interfacesOfObjectTypesMap = /* @__PURE__ */ new Map();
  const parseObjectType = (type, typeName = type.name) => {
    const fields = type.getFields();
    const interfaces = type.getInterfaces();
    if (interfaces.length) {
      interfacesOfObjectTypesMap.set(type.name, interfaces.map((v) => v.name));
      for (const interfaceType of interfaces) {
        let objectTypesList = unionsAndInterfacesObjectTypesMap.get(interfaceType.name);
        if (objectTypesList == null) {
          unionsAndInterfacesObjectTypesMap.set(interfaceType.name, objectTypesList = []);
        }
        objectTypesList.push(type.name);
      }
    }
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const objectFieldsDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    Object.entries(fields).forEach(([fieldName, gqlType]) => {
      if (gqlType.description || gqlType.deprecationReason) {
        objectFieldsDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.deprecationReason
        };
      }
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore)
              return;
          }
        }
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
    });
    fieldsDescriptions.set(type.name, objectFieldsDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    generatedSchema[typeName] = schemaType;
  };
  const unionsAndInterfacesObjectTypesMap = /* @__PURE__ */ new Map();
  const parseUnionType = (type) => {
    const unionTypes = type.getTypes();
    const list = [];
    unionsAndInterfacesObjectTypesMap.set(type.name, list);
    for (const objectType of unionTypes) {
      list.push(objectType.name);
    }
    generatedSchema[type.name] = {
      __typename: { __type: "String!" }
    };
  };
  const parseInputType = (type) => {
    inputTypeNames.add(type.name);
    const fields = type.getFields();
    const schemaType = {};
    Object.entries(fields).forEach(([key, value]) => {
      schemaType[key] = {
        __type: value.type.toString()
      };
      if (value.description || value.deprecationReason || value.defaultValue) {
        ({
          description: value.description,
          deprecated: value.deprecationReason,
          defaultValue: value.defaultValue != null ? JSON.stringify(value.defaultValue) : null
        });
      }
    });
    generatedSchema[type.name] = schemaType;
  };
  const parseInterfaceType = (type) => {
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const fields = type.getFields();
    const interfaceFieldDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    Object.entries(fields).forEach(([fieldName, gqlType]) => {
      ({
        fieldName,
        __type: gqlType.type.toString()
      });
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      let hasArgs = true;
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore) {
              hasArgs = false;
            }
          }
        }
      } else {
        hasArgs = false;
      }
      if (hasArgs) {
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
      if (gqlType.description || gqlType.deprecationReason) {
        interfaceFieldDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.deprecationReason
        };
      }
    });
    fieldsDescriptions.set(type.name, interfaceFieldDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    generatedSchema[type.name] = schemaType;
  };
  config.types.forEach((type) => {
    if (type.description) {
      descriptions.set(type.name, type.description);
    }
    if (type.name.startsWith("__") || type === queryType || type === mutationType || type === subscriptionType) {
      return;
    }
    if (isScalarType(type)) {
      parseScalarType(type);
    } else if (isObjectType(type)) {
      parseObjectType(type);
    } else if (isInterfaceType(type)) {
      parseInterfaceType(type);
    } else if (isUnionType(type)) {
      parseUnionType(type);
    } else if (isEnumType(type)) {
      parseEnumType(type);
    } else if (isInputObjectType(type)) {
      parseInputType(type);
    }
  });
  if (queryType) {
    parseObjectType(queryType, "query");
  }
  if (mutationType) {
    parseObjectType(mutationType, "mutation");
  }
  if (subscriptionType) {
    parseObjectType(subscriptionType, "subscription");
  }
  const unionsMapObj = Array.from(unionsAndInterfacesObjectTypesMap.entries()).reduce((acum, [key, value]) => {
    generatedSchema[key]["$on"] = {
      __type: `$${key}!`
    };
    acum[key] = value;
    return acum;
  }, {});
  if (unionsAndInterfacesObjectTypesMap.size) {
    generatedSchema[SchemaUnionsKey] = unionsMapObj;
  }
  function parseArgType({
    pureType,
    isArray,
    nullableItems,
    isNullable,
    hasDefaultValue
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? enumsNames.includes(pureType) ? pureType : `Scalars["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable || hasDefaultValue) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  function parseFinalType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? `ScalarsEnums["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  const objectTypeTSTypes = /* @__PURE__ */ new Map();
  let typescriptTypes = deps.sortBy(Object.entries(generatedSchema), (v) => v[0]).reduce((acum, [typeKey, typeValue]) => {
    const typeName = (() => {
      switch (typeKey) {
        case "query": {
          return "Query";
        }
        case "mutation": {
          return "Mutation";
        }
        case "subscription": {
          return "Subscription";
        }
        default: {
          return typeKey;
        }
      }
    })();
    if (inputTypeNames.has(typeName))
      return acum;
    const objectTypeMap = /* @__PURE__ */ new Map();
    if (!unionsAndInterfacesObjectTypesMap.has(typeName)) {
      objectTypeTSTypes.set(typeName, objectTypeMap);
    }
    const interfaceOrUnionsObjectTypes = unionsAndInterfacesObjectTypesMap.get(typeName);
    acum += `

      ${addDescription(typeName)}export interface ${typeName} { 
        __typename?: ${interfaceOrUnionsObjectTypes ? interfaceOrUnionsObjectTypes.map((v) => `"${v}"`).join(" | ") : `"${typeName}"`}; ${Object.entries(typeValue).reduce((acum2, [fieldKey, fieldValue]) => {
      if (fieldKey === "__typename") {
        objectTypeMap.set(fieldKey, `?: "${typeName}"`);
        return acum2;
      }
      const typeFieldArgDescriptions = fieldsArgsDescriptions.has(typeName) ? fieldsArgsDescriptions.get(typeName) : void 0;
      const argDescriptions = typeFieldArgDescriptions && typeFieldArgDescriptions[fieldKey] ? typeFieldArgDescriptions[fieldKey] : {};
      const fieldValueProps = parseSchemaType(fieldValue.__type);
      const typeToReturn = parseFinalType(fieldValueProps);
      let finalType;
      if (fieldValue.__args) {
        const argsEntries = Object.entries(fieldValue.__args);
        let onlyNullableArgs = true;
        const argTypes = argsEntries.reduce((acum3, [argKey, argValue]) => {
          const argValueProps = parseSchemaType(argValue, argDescriptions[argKey]);
          const connector = argValueProps.isNullable || argValueProps.hasDefaultValue ? "?:" : ":";
          if (!argValueProps.isNullable) {
            onlyNullableArgs = false;
          }
          const argTypeValue = parseArgType(argValueProps);
          acum3 += `${addDescription([
            typeName,
            fieldKey,
            argKey
          ])}${argKey}${connector} ${argTypeValue};
`;
          return acum3;
        }, "");
        const argsConnector = onlyNullableArgs ? "?:" : ":";
        finalType = `: (args${argsConnector} {${argTypes}}) => ${typeToReturn}`;
      } else {
        const connector = fieldValueProps.isNullable ? "?:" : ":";
        finalType = `${connector} ${typeToReturn}`;
      }
      objectTypeMap.set(fieldKey, finalType);
      acum2 += "\n" + addDescription([typeName, fieldKey]) + fieldKey + finalType;
      return acum2;
    }, "")}
      }
      `;
    return acum;
  }, "");
  const objectTypesEntries = deps.sortBy(Array.from(objectTypeTSTypes.entries()), (v) => v[0]);
  typescriptTypes += `
  export interface SchemaObjectTypes {
    ${objectTypesEntries.reduce((acum, [typeName]) => {
    acum += `${typeName}:${typeName};`;
    return acum;
  }, "")}
  }
  export type SchemaObjectTypesNames = ${objectTypesEntries.map(([key]) => `"${key}"`).join(" | ")};
  `;
  if (unionsAndInterfacesObjectTypesMap.size) {
    typescriptTypes += `
    ${deps.sortBy(Array.from(unionsAndInterfacesObjectTypesMap.entries()), (v) => v[0]).reduce((acum, [unionInterfaceName, objectTypes]) => {
      acum += `
      export interface $${unionInterfaceName} {
        ${objectTypes.map((typeName) => `${typeName}?:${typeName}`).join("\n")}
      }
      `;
      return acum;
    }, "")}
    `;
  }
  typescriptTypes += `
    export interface GeneratedSchema {
      query: Query
      mutation: Mutation
      subscription: Subscription
    }
    `;
  typescriptTypes += `
    export type MakeNullable<T> = {
      [K in keyof T]: T[K] | undefined;
    };
  
    export interface ScalarsEnums extends MakeNullable<Scalars> {
      ${deps.sortBy(enumsNames).reduce((acum, enumName) => {
    acum += `${enumName}: ${enumName} | undefined;`;
    return acum;
  }, "")}
    }
    `;
  function typeDoc(type) {
    return `/**
 * @type {${type}}
 */
`;
  }
  const queryFetcher = `
    ${isJavascriptOutput ? typeDoc('import("gqty").QueryFetcher') + "const queryFetcher" : "const queryFetcher : QueryFetcher"} = async function (query, variables, fetchOptions) {
        // Modify "${endpoint}" if needed
        const response = await fetch("${endpoint}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            query,
            variables,
          }),
          mode: "cors",
          ...fetchOptions
        });

        const json = await response.json();
      
        return json;
      };
    `;
  const hasUnions = !!unionsAndInterfacesObjectTypesMap.size;
  const scalarsEnumsHashString = JSON.stringify(Object.keys(scalarsEnumsHash).sort().reduce((acum, key) => {
    acum[key] = true;
    return acum;
  }, {}));
  const generatedSchemaCodeString = deps.sortBy(Object.entries(generatedSchema), (v) => v[0]).reduceRight((acum, [key, value]) => {
    return `${JSON.stringify(key)}:${JSON.stringify(value)}, ${acum}`;
  }, hasUnions ? `[SchemaUnionsKey]: ${JSON.stringify(unionsMapObj)}` : "");
  const javascriptSchemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

${typeDoc('import("gqty").ScalarsEnumsHash')}export const scalarsEnumsHash = ${scalarsEnumsHashString};

export const generatedSchema = {${generatedSchemaCodeString}};
  `);
  const schemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
  ${preImport}

  ${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

  ${await codegenResultPromise}

  export${isJavascriptOutput ? " declare" : ""} const scalarsEnumsHash: import("gqty").ScalarsEnumsHash${isJavascriptOutput ? ";" : ` = ${scalarsEnumsHashString};`}
  export${isJavascriptOutput ? " declare" : ""} const generatedSchema ${isJavascriptOutput ? ":" : "="} {${generatedSchemaCodeString}}${isJavascriptOutput ? "" : " as const"};

  ${typescriptTypes}
    `);
  let reactClientCode = "";
  if (react) {
    if (isJavascriptOutput) {
      reactClientCode = `
      ${typeDoc('import("@gqty/react").ReactClient<import("./schema.generated").GeneratedSchema>')}const reactClient = createReactClient(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });

      const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
      } = reactClient;

      export { 
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
       }
      `.trim();
    } else {
      reactClientCode = `
      const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
      } = createReactClient<GeneratedSchema>(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });
      
      export { 
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
       }
      `;
    }
  }
  const clientCode = await format(`
/**
 * GQTY: You can safely modify this file and Query Fetcher based on your needs
 */

  ${react ? `import { createReactClient } from "@gqty/react"` : ""}
  ${subscriptions ? `import { createSubscriptionsClient } from "@gqty/subscriptions"` : ""}
  ${isJavascriptOutput ? "" : 'import type { QueryFetcher } from "gqty";'}
  import { createClient } from "gqty";
  ${isJavascriptOutput ? "" : 'import type { GeneratedSchema, SchemaObjectTypes, SchemaObjectTypesNames } from "./schema.generated";'}
  import { generatedSchema, scalarsEnumsHash } from "./schema.generated";


  ${queryFetcher}

  ${subscriptions ? `
  const subscriptionsClient = 
  typeof window !== "undefined" ?
  createSubscriptionsClient({
    wsEndpoint: () => {
      // Modify if needed
      const url = new URL("${endpoint}", window.location.href);
      url.protocol = url.protocol.replace('http', 'ws');
      return url.href;
    }
  }) : undefined;
  ` : ""}

  ${isJavascriptOutput ? `${typeDoc('import("gqty").GQtyClient<import("./schema.generated").GeneratedSchema>')}export const client = createClient({
        schema: generatedSchema,
        scalarsEnumsHash, 
        queryFetcher
        ${subscriptions ? ", subscriptionsClient" : ""}
      });` : `export const client = createClient<GeneratedSchema, SchemaObjectTypesNames, SchemaObjectTypes>({ 
    schema: generatedSchema, 
    scalarsEnumsHash, 
    queryFetcher
    ${subscriptions ? ", subscriptionsClient" : ""}
  });`}
  

  const { query, mutation, mutate, subscription, resolved, refetch, track } = client;

  export { query, mutation, mutate, subscription, resolved, refetch, track };

  ${reactClientCode}

  export * from "./schema.generated";
  `);
  return {
    clientCode,
    schemaCode,
    javascriptSchemaCode,
    generatedSchema,
    scalarsEnumsHash,
    isJavascriptOutput
  };
}

export { generate };
