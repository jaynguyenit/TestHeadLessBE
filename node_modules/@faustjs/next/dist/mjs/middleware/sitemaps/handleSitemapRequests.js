import { createPagesSitemap, createRootSitemapIndex, handleSitemapPath, handleRobotsTxt, } from './createSitemaps.js';
import { isArray, isBoolean, isString, isUndefined, isObject, isFunction, } from './sitemapUtils.js';
/**
 * The pathname to the Next.js pages sitemap file. We may want to make this
 * configurable in the future.
 */
export const FAUST_PAGES_PATHNAME = '/sitemap-faust-pages.xml';
/**
 * The pathname to the robots.txt file.
 */
export const FAUST_ROBOTS_PATHNAME = '/robots.txt';
/**
 * Validates the structure of the user defined config.
 *
 * @param {Partial<HandleSitemapRequestsConfig>} config The user provided config
 */
export function validateConfig(config, isMiddleware = true) {
    var _a, _b;
    if (isUndefined(config === null || config === void 0 ? void 0 : config.wpUrl)) {
        throw new Error('wpUrl is required.');
    }
    if (!isString(config === null || config === void 0 ? void 0 : config.wpUrl)) {
        throw new Error('wpUrl must be a string.');
    }
    try {
        // eslint-disable-next-line no-new
        new URL(config.wpUrl);
    }
    catch (e) {
        throw new Error('wpUrl must be a valid URL.');
    }
    if (!isMiddleware) {
        if (isUndefined(config === null || config === void 0 ? void 0 : config.frontendUrl)) {
            throw new Error('frontendUrl is required');
        }
        if (!isString(config === null || config === void 0 ? void 0 : config.frontendUrl)) {
            throw new Error('frontendUrl must be a string');
        }
        try {
            // eslint-disable-next-line no-new
            new URL(config.frontendUrl);
        }
        catch (e) {
            throw new Error('frontendUrl must be a valid URL.');
        }
    }
    if (isUndefined(config === null || config === void 0 ? void 0 : config.sitemapIndexPath)) {
        throw new Error('sitemapIndexPath is required');
    }
    if (!isString(config === null || config === void 0 ? void 0 : config.sitemapIndexPath)) {
        throw new Error('sitemapIndexPath must be a string');
    }
    if (!(config === null || config === void 0 ? void 0 : config.sitemapIndexPath.startsWith('/'))) {
        throw new Error('sitemapIndexPath must start with a forward slash');
    }
    if (!isUndefined(config === null || config === void 0 ? void 0 : config.sitemapPathsToIgnore)) {
        if (!isArray(config.sitemapPathsToIgnore)) {
            throw new Error('sitemapPathsToIgnore must be an array');
        }
        (_a = config === null || config === void 0 ? void 0 : config.sitemapPathsToIgnore) === null || _a === void 0 ? void 0 : _a.forEach((path) => {
            if (!isString(path)) {
                throw new Error('sitemapPathsToIgnore must be an array of strings');
            }
            if (!path.startsWith('/')) {
                throw new Error('Each sitemapPathsToIgnore must start with a forward slash');
            }
            if (path.includes('*') && !path.endsWith('*')) {
                throw new Error('sitemapPathsToIgnore with a wildcard must end with a wildcard');
            }
        });
    }
    // Validate pages structure and required values
    if (!isUndefined(config === null || config === void 0 ? void 0 : config.pages)) {
        if (!isArray(config.pages)) {
            throw new Error('pages must be an array');
        }
        (_b = config === null || config === void 0 ? void 0 : config.pages) === null || _b === void 0 ? void 0 : _b.forEach((page) => {
            if (!isObject(page)) {
                throw new Error('pages must be an array of objects');
            }
            if (isUndefined(page.path)) {
                throw new Error('pages must have a path property');
            }
            if (!isString(page.path)) {
                throw new Error('The pages path property must be a string');
            }
        });
    }
    // Validate replaceUrls is a boolean
    if (!isUndefined(config === null || config === void 0 ? void 0 : config.replaceUrls) && !isBoolean(config === null || config === void 0 ? void 0 : config.replaceUrls)) {
        throw new Error('replaceUrls must be a boolean');
    }
    // Validate robotsTxt is a function
    if (!isUndefined(config === null || config === void 0 ? void 0 : config.robotsTxt) && !isFunction(config === null || config === void 0 ? void 0 : config.robotsTxt)) {
        throw new Error('robotsTxt must be a function');
    }
}
/**
 * Next.js middleware to proxy sitemap requests from the WordPress site.
 *
 * @param req The Next.js middleware request object
 * @param config The user specified config object
 * @returns {Response|undefined} A response object if the current request
 * is for a sitemap that needs to be handled, undefined otherwise
 */
export async function handleSitemapRequests(req, config) {
    var _a;
    // Validate config structure
    validateConfig(config);
    // Normalize config if some optional values are missing
    // eslint-disable-next-line prefer-object-spread
    const normalizedConfig = Object.assign({}, { replaceUrls: true }, config);
    const { pathname } = new URL(req.url);
    const { sitemapIndexPath, pages, robotsTxt } = normalizedConfig;
    // Handle the root XML sitemap if specified in the config
    if (pathname === sitemapIndexPath) {
        return createRootSitemapIndex(req, normalizedConfig);
    }
    // Handle the sitemap for the specified Next.js pages if specified in the config
    if (pathname === FAUST_PAGES_PATHNAME && (pages === null || pages === void 0 ? void 0 : pages.length)) {
        return createPagesSitemap(req, normalizedConfig);
    }
    // Handle the robots.txt file if specified in the config
    if (pathname === FAUST_ROBOTS_PATHNAME && robotsTxt) {
        return handleRobotsTxt(req, normalizedConfig);
    }
    // Handle the sitemap index paths specified in the config
    if (pathname.includes('sitemap') &&
        pathname.endsWith('.xml') &&
        !((_a = normalizedConfig === null || normalizedConfig === void 0 ? void 0 : normalizedConfig.sitemapPathsToIgnore) === null || _a === void 0 ? void 0 : _a.includes(pathname))) {
        return handleSitemapPath(req, normalizedConfig);
    }
    /**
     * If the above conditions are not met, return undefined and go on to the
     * next middleware
     */
    return undefined;
}
