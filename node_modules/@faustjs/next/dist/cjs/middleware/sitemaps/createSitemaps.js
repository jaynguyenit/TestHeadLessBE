"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRobotsTxt = exports.handleSitemapPath = exports.createPagesSitemap = exports.createRootSitemapIndex = void 0;
const common_tags_1 = require("common-tags");
const fast_xml_parser_1 = require("fast-xml-parser");
const handleSitemapRequests_js_1 = require("./handleSitemapRequests.js");
const sitemapUtils_js_1 = require("./sitemapUtils.js");
const parserConfig = {
    ignoreAttributes: false,
    preserveOrder: false,
    unpairedTags: ['xml', 'xml-stylesheet'],
    processEntities: true,
    htmlEntities: true,
};
/**
 * Creates the root XML sitemap index (e.g. /sitemap.xml) that lists all the
 * sitemaps provided as the sitemapPaths property in the config, in addition to
 * a sitemap for the Next.js pages provided as the pages property in the config.
 *
 * @param {NextRequest} req The Next.js middleware request object
 * @param {NormalizedConfig} normalizedConfig A normalized config object
 * @returns {Response|undefined}
 */
async function createRootSitemapIndex(req, normalizedConfig, isMiddleware = true) {
    var _a;
    const { pages, sitemapPathsToIgnore, replaceUrls, wpUrl } = normalizedConfig;
    if (!req.url) {
        throw new Error('Request object must have URL');
    }
    let wpSitemapUrl = '';
    let frontendUrl = '';
    if (isMiddleware) {
        const { pathname, origin } = new URL(req.url);
        frontendUrl = origin;
        wpSitemapUrl = `${(0, sitemapUtils_js_1.trimSlashes)(wpUrl)}/${(0, sitemapUtils_js_1.trimSlashes)(pathname)}`;
    }
    else {
        // get sitemapIndexPath config param
        // fetch sitemap from WP
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        wpSitemapUrl = `${(0, sitemapUtils_js_1.trimSlashes)(wpUrl)}/${(0, sitemapUtils_js_1.trimSlashes)(normalizedConfig.sitemapIndexPath)}`;
        frontendUrl = normalizedConfig.frontendUrl;
    }
    let sitemaps = [];
    if (!(0, sitemapUtils_js_1.isUndefined)(pages) && (0, sitemapUtils_js_1.isArray)(pages) && pages.length) {
        let sitemapFaustPagesUrl = '';
        if (isMiddleware) {
            sitemapFaustPagesUrl = `${(0, sitemapUtils_js_1.trimSlashes)(frontendUrl)}/${(0, sitemapUtils_js_1.trimSlashes)(handleSitemapRequests_js_1.FAUST_PAGES_PATHNAME)}`;
        }
        else {
            sitemapFaustPagesUrl = `${(0, sitemapUtils_js_1.trimSlashes)(frontendUrl)}/sitemap.xml?sitemap=${(0, sitemapUtils_js_1.trimSlashes)(handleSitemapRequests_js_1.FAUST_PAGES_PATHNAME)}`;
        }
        sitemaps = [
            ...sitemaps,
            {
                loc: encodeURI(sitemapFaustPagesUrl),
            },
        ];
    }
    const res = await fetch(wpSitemapUrl);
    // Don't proxy the sitemap index if the response was not ok.
    if (!res.ok) {
        return undefined;
    }
    const xmlRes = await res.text();
    /**
     * Create a parser to convert our XML data into a JS object
     *
     * @link https://github.com/NaturalIntelligence/fast-xml-parser/blob/HEAD/docs/v4/6.HTMLParsing.md
     */
    const parser = new fast_xml_parser_1.XMLParser(Object.assign(Object.assign({}, parserConfig), { 
        /**
         * FXP can not determine if a single tag should be parsed as an array or
         * an object, so we need to specify we always want "sitemap" tags to be an
         * array.
         *
         * @see https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#isarray
         */
        isArray: (tagName) => {
            return tagName === 'sitemap';
        } }));
    // JS object representation of the XML sitemap index
    const parsedSitemapIndex = parser.parse(xmlRes);
    let wpSitemaps = (_a = parsedSitemapIndex === null || parsedSitemapIndex === void 0 ? void 0 : parsedSitemapIndex.sitemapindex) === null || _a === void 0 ? void 0 : _a.sitemap;
    // The XML we parsed was not a proper sitemap
    if ((0, sitemapUtils_js_1.isUndefined)(wpSitemaps)) {
        return undefined;
    }
    /**
     * Ignore paths with exact matches to the sitemapPathsToIgnore property
     */
    wpSitemaps = wpSitemaps.filter((sitemap) => {
        const { pathname: sitemapPathname } = new URL(sitemap.loc);
        return !(sitemapPathsToIgnore === null || sitemapPathsToIgnore === void 0 ? void 0 : sitemapPathsToIgnore.includes(sitemapPathname));
    });
    /**
     * Ignore paths from sitemapPathsToIgnore property that end in a wildcard
     */
    const wildcardPathsToIgnore = sitemapPathsToIgnore === null || sitemapPathsToIgnore === void 0 ? void 0 : sitemapPathsToIgnore.filter((path) => path.endsWith('*'));
    wpSitemaps = wpSitemaps.filter((sitemap) => {
        const { pathname: sitemapPathname } = new URL(sitemap.loc);
        let hasWildcard = false;
        wildcardPathsToIgnore === null || wildcardPathsToIgnore === void 0 ? void 0 : wildcardPathsToIgnore.forEach((path) => {
            const pathLessWildcard = path.slice(0, -1);
            if (sitemapPathname.startsWith(pathLessWildcard)) {
                hasWildcard = true;
            }
        });
        return !hasWildcard;
    });
    /**
     * Replace the existing WordPress URL in each "loc" with the headless URL
     * if necessary
     *
     * @example
     * Replaces http://headless.local/wp-sitemap-posts-page-1.xml with
     * http://localhost:3000/wp-sitemap-posts-page-1.xml
     */
    if (replaceUrls) {
        wpSitemaps.forEach((sitemap) => {
            let sitemapUrl = '';
            if (isMiddleware) {
                sitemapUrl = sitemap.loc.replace((0, sitemapUtils_js_1.trimSlashes)(wpUrl), (0, sitemapUtils_js_1.trimSlashes)(frontendUrl));
            }
            else {
                const url = new URL(sitemap.loc);
                sitemapUrl = `${(0, sitemapUtils_js_1.trimSlashes)(frontendUrl)}/sitemap.xml?sitemap=${(0, sitemapUtils_js_1.trimSlashes)(url.pathname)}`;
            }
            sitemaps = [
                ...sitemaps,
                Object.assign(Object.assign({}, sitemap), { loc: sitemapUrl }),
            ];
        });
    }
    else {
        sitemaps = [...sitemaps, ...wpSitemaps];
    }
    return (0, sitemapUtils_js_1.createSitemapIndex)(sitemaps);
}
exports.createRootSitemapIndex = createRootSitemapIndex;
/**
 * Creates a sitemap for the Next.js pages specified in the "pages" config option
 *
 * @param req The Next.js middleware request object
 * @param normalizedConfig A normalized config object
 * @returns {Response|undefined}
 */
function createPagesSitemap(req, normalizedConfig, isMiddleware = true) {
    if (!req.url) {
        throw new Error('Request object must have URL');
    }
    let frontendUrl = '';
    if (isMiddleware) {
        const { origin } = new URL(req.url);
        frontendUrl = origin;
    }
    else {
        frontendUrl = normalizedConfig.frontendUrl;
    }
    const { pages } = normalizedConfig;
    if ((0, sitemapUtils_js_1.isUndefined)(pages) || !(0, sitemapUtils_js_1.isArray)(pages) || !pages.length) {
        return undefined;
    }
    let urls = [];
    pages.forEach((page) => {
        urls = [
            ...urls,
            {
                loc: `${(0, sitemapUtils_js_1.trimSlashes)(frontendUrl)}/${(0, sitemapUtils_js_1.trimSlashes)(page.path)}`,
                lastmod: page === null || page === void 0 ? void 0 : page.lastmod,
                changefreq: page === null || page === void 0 ? void 0 : page.changefreq,
                priority: page === null || page === void 0 ? void 0 : page.priority,
            },
        ];
    });
    return (0, sitemapUtils_js_1.createSitemap)(urls);
}
exports.createPagesSitemap = createPagesSitemap;
/**
 * Handles a request to a sitemap path listed in the sitemapPaths config option
 *
 * @param req The Next.js middleware request object
 * @param normalizedConfig A normalized config object
 * @returns {Promise<Response|Undefined>}
 */
async function handleSitemapPath(req, normalizedConfig, isMiddleware = true) {
    var _a;
    const { wpUrl, replaceUrls } = normalizedConfig;
    if (!req.url) {
        throw new Error('Request object must have URL');
    }
    let wpSitemapUrl = '';
    let frontendUrl = '';
    if (isMiddleware) {
        const { pathname, origin } = new URL(req.url);
        frontendUrl = origin;
        wpSitemapUrl = `${(0, sitemapUtils_js_1.trimSlashes)(wpUrl)}/${(0, sitemapUtils_js_1.trimSlashes)(pathname)}`;
    }
    else {
        const paramsIndex = req.url.indexOf('?');
        const searchParamString = req.url.substr(paramsIndex);
        const urlParams = new URLSearchParams(searchParamString);
        const sitemapPath = urlParams.get('sitemap');
        wpSitemapUrl = `${(0, sitemapUtils_js_1.trimSlashes)(wpUrl)}/${(0, sitemapUtils_js_1.trimSlashes)(sitemapPath)}`;
        frontendUrl = normalizedConfig.frontendUrl;
    }
    const res = await fetch(wpSitemapUrl);
    // Don't proxy the sitemap if the response was not ok.
    if (!res.ok) {
        return undefined;
    }
    const xmlRes = await res.text();
    /**
     * Create a parser to convert our XML data into a JS object
     *
     * @link https://github.com/NaturalIntelligence/fast-xml-parser/blob/HEAD/docs/v4/6.HTMLParsing.md
     */
    const parser = new fast_xml_parser_1.XMLParser(Object.assign(Object.assign({}, parserConfig), { 
        /**
         * FXP can not determine if a single tag should be parsed as an array or
         * an object, so we need to specify we always want "url" tags to be an
         * array.
         *
         * @see https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#isarray
         */
        isArray: (tagName) => {
            return tagName === 'url';
        } }));
    // JS object representation of the XML sitemap
    const parsedSitemap = parser.parse(xmlRes);
    const wpSitemapUrls = (_a = parsedSitemap === null || parsedSitemap === void 0 ? void 0 : parsedSitemap.urlset) === null || _a === void 0 ? void 0 : _a.url;
    // The XML we parsed was not a proper sitemap
    if ((0, sitemapUtils_js_1.isUndefined)(wpSitemapUrls)) {
        return undefined;
    }
    let urls = [];
    if (replaceUrls) {
        /**
         * Replace the existing WordPress URL in each "loc" with the headless URL
         *
         * @example
         * Replaces http://headless.local/wp-sitemap-posts-page-1.xml with
         * http://localhost:3000/wp-sitemap-posts-page-1.xml
         */
        wpSitemapUrls.forEach((url) => {
            urls = [
                ...urls,
                Object.assign(Object.assign({}, url), { loc: url.loc.replace((0, sitemapUtils_js_1.trimSlashes)(wpUrl), (0, sitemapUtils_js_1.trimSlashes)(frontendUrl)) }),
            ];
        });
    }
    else {
        urls = wpSitemapUrls;
    }
    return (0, sitemapUtils_js_1.createSitemap)(urls);
}
exports.handleSitemapPath = handleSitemapPath;
/**
 * Handles a request to the `/robots.txt` path
 *
 * @param req The Next.js middleware request object
 * @param normalizedConfig A normalized config object
 * @returns {Promise<Response|Undefined>}
 */
async function handleRobotsTxt(req, normalizedConfig) {
    const { origin } = new URL(req.url);
    const { sitemapIndexPath, robotsTxt } = normalizedConfig;
    if (robotsTxt === undefined || robotsTxt === null) {
        return undefined;
    }
    const sitemapUrl = `${(0, sitemapUtils_js_1.trimSlashes)(origin)}/${(0, sitemapUtils_js_1.trimSlashes)(sitemapIndexPath)}`;
    let text = await robotsTxt(sitemapUrl);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    text = (0, common_tags_1.stripIndent) `
    ${text}
  `;
    const response = new Response(text);
    response.headers.set('Content-Type', 'text/plain');
    return response;
}
exports.handleRobotsTxt = handleRobotsTxt;
