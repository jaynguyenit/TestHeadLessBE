"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSitemapRequests = exports.validateConfig = exports.FAUST_ROBOTS_PATHNAME = exports.FAUST_PAGES_PATHNAME = void 0;
const createSitemaps_js_1 = require("./createSitemaps.js");
const sitemapUtils_js_1 = require("./sitemapUtils.js");
/**
 * The pathname to the Next.js pages sitemap file. We may want to make this
 * configurable in the future.
 */
exports.FAUST_PAGES_PATHNAME = '/sitemap-faust-pages.xml';
/**
 * The pathname to the robots.txt file.
 */
exports.FAUST_ROBOTS_PATHNAME = '/robots.txt';
/**
 * Validates the structure of the user defined config.
 *
 * @param {Partial<HandleSitemapRequestsConfig>} config The user provided config
 */
function validateConfig(config, isMiddleware = true) {
    var _a, _b;
    if ((0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.wpUrl)) {
        throw new Error('wpUrl is required.');
    }
    if (!(0, sitemapUtils_js_1.isString)(config === null || config === void 0 ? void 0 : config.wpUrl)) {
        throw new Error('wpUrl must be a string.');
    }
    try {
        // eslint-disable-next-line no-new
        new URL(config.wpUrl);
    }
    catch (e) {
        throw new Error('wpUrl must be a valid URL.');
    }
    if (!isMiddleware) {
        if ((0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.frontendUrl)) {
            throw new Error('frontendUrl is required');
        }
        if (!(0, sitemapUtils_js_1.isString)(config === null || config === void 0 ? void 0 : config.frontendUrl)) {
            throw new Error('frontendUrl must be a string');
        }
        try {
            // eslint-disable-next-line no-new
            new URL(config.frontendUrl);
        }
        catch (e) {
            throw new Error('frontendUrl must be a valid URL.');
        }
    }
    if ((0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.sitemapIndexPath)) {
        throw new Error('sitemapIndexPath is required');
    }
    if (!(0, sitemapUtils_js_1.isString)(config === null || config === void 0 ? void 0 : config.sitemapIndexPath)) {
        throw new Error('sitemapIndexPath must be a string');
    }
    if (!(config === null || config === void 0 ? void 0 : config.sitemapIndexPath.startsWith('/'))) {
        throw new Error('sitemapIndexPath must start with a forward slash');
    }
    if (!(0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.sitemapPathsToIgnore)) {
        if (!(0, sitemapUtils_js_1.isArray)(config.sitemapPathsToIgnore)) {
            throw new Error('sitemapPathsToIgnore must be an array');
        }
        (_a = config === null || config === void 0 ? void 0 : config.sitemapPathsToIgnore) === null || _a === void 0 ? void 0 : _a.forEach((path) => {
            if (!(0, sitemapUtils_js_1.isString)(path)) {
                throw new Error('sitemapPathsToIgnore must be an array of strings');
            }
            if (!path.startsWith('/')) {
                throw new Error('Each sitemapPathsToIgnore must start with a forward slash');
            }
            if (path.includes('*') && !path.endsWith('*')) {
                throw new Error('sitemapPathsToIgnore with a wildcard must end with a wildcard');
            }
        });
    }
    // Validate pages structure and required values
    if (!(0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.pages)) {
        if (!(0, sitemapUtils_js_1.isArray)(config.pages)) {
            throw new Error('pages must be an array');
        }
        (_b = config === null || config === void 0 ? void 0 : config.pages) === null || _b === void 0 ? void 0 : _b.forEach((page) => {
            if (!(0, sitemapUtils_js_1.isObject)(page)) {
                throw new Error('pages must be an array of objects');
            }
            if ((0, sitemapUtils_js_1.isUndefined)(page.path)) {
                throw new Error('pages must have a path property');
            }
            if (!(0, sitemapUtils_js_1.isString)(page.path)) {
                throw new Error('The pages path property must be a string');
            }
        });
    }
    // Validate replaceUrls is a boolean
    if (!(0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.replaceUrls) && !(0, sitemapUtils_js_1.isBoolean)(config === null || config === void 0 ? void 0 : config.replaceUrls)) {
        throw new Error('replaceUrls must be a boolean');
    }
    // Validate robotsTxt is a function
    if (!(0, sitemapUtils_js_1.isUndefined)(config === null || config === void 0 ? void 0 : config.robotsTxt) && !(0, sitemapUtils_js_1.isFunction)(config === null || config === void 0 ? void 0 : config.robotsTxt)) {
        throw new Error('robotsTxt must be a function');
    }
}
exports.validateConfig = validateConfig;
/**
 * Next.js middleware to proxy sitemap requests from the WordPress site.
 *
 * @param req The Next.js middleware request object
 * @param config The user specified config object
 * @returns {Response|undefined} A response object if the current request
 * is for a sitemap that needs to be handled, undefined otherwise
 */
async function handleSitemapRequests(req, config) {
    var _a;
    // Validate config structure
    validateConfig(config);
    // Normalize config if some optional values are missing
    // eslint-disable-next-line prefer-object-spread
    const normalizedConfig = Object.assign({}, { replaceUrls: true }, config);
    const { pathname } = new URL(req.url);
    const { sitemapIndexPath, pages, robotsTxt } = normalizedConfig;
    // Handle the root XML sitemap if specified in the config
    if (pathname === sitemapIndexPath) {
        return (0, createSitemaps_js_1.createRootSitemapIndex)(req, normalizedConfig);
    }
    // Handle the sitemap for the specified Next.js pages if specified in the config
    if (pathname === exports.FAUST_PAGES_PATHNAME && (pages === null || pages === void 0 ? void 0 : pages.length)) {
        return (0, createSitemaps_js_1.createPagesSitemap)(req, normalizedConfig);
    }
    // Handle the robots.txt file if specified in the config
    if (pathname === exports.FAUST_ROBOTS_PATHNAME && robotsTxt) {
        return (0, createSitemaps_js_1.handleRobotsTxt)(req, normalizedConfig);
    }
    // Handle the sitemap index paths specified in the config
    if (pathname.includes('sitemap') &&
        pathname.endsWith('.xml') &&
        !((_a = normalizedConfig === null || normalizedConfig === void 0 ? void 0 : normalizedConfig.sitemapPathsToIgnore) === null || _a === void 0 ? void 0 : _a.includes(pathname))) {
        return (0, createSitemaps_js_1.handleSitemapPath)(req, normalizedConfig);
    }
    /**
     * If the above conditions are not met, return undefined and go on to the
     * next middleware
     */
    return undefined;
}
exports.handleSitemapRequests = handleSitemapRequests;
