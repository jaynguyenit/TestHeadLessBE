import { sha1 } from '@gqty/utils/sha1';
import { serializeVariables } from '../Utils/cachedJSON.mjs';
import { SelectionType, Selection } from './selection.mjs';

function separateSelectionTypes(selections) {
  let querySelections;
  let mutationSelections;
  let subscriptionSelections;
  for (const selection of selections) {
    switch (selection.type) {
      case SelectionType.Query: {
        querySelections || (querySelections = []);
        querySelections.push(selection);
        break;
      }
      case SelectionType.Mutation: {
        mutationSelections || (mutationSelections = []);
        mutationSelections.push(selection);
        break;
      }
      case SelectionType.Subscription: {
        subscriptionSelections || (subscriptionSelections = []);
        subscriptionSelections.push(selection);
        break;
      }
    }
  }
  return {
    querySelections,
    mutationSelections,
    subscriptionSelections
  };
}
const selectionsBackupVersion = "v1";
function isSelectionsBackup(selectionsBackup) {
  return Array.isArray(selectionsBackup) && Array.isArray(selectionsBackup[0]) && selectionsBackup[1] === selectionsBackupVersion;
}
let uniqueSelectionId = 0;
function createSelectionManager() {
  const selectionCache = /* @__PURE__ */ new Map();
  const stringsHash = {};
  let restoredBackup;
  function getSerializedVariablesId(variables) {
    const serializedVariables = serializeVariables(variables);
    let hashId;
    if ((hashId = stringsHash[serializedVariables]) === void 0) {
      hashId = stringsHash[serializedVariables] = sha1(serializedVariables).slice(0, 5);
      if (restoredBackup)
        restoredBackup[0].push([serializedVariables, hashId]);
    }
    return hashId;
  }
  function restore(backup2) {
    if (!isSelectionsBackup(backup2))
      return;
    restoredBackup = backup2;
    for (const [stringKey, hashIdValue] of backup2[0]) {
      stringsHash[stringKey] = hashIdValue;
    }
  }
  function backup() {
    if (restoredBackup) {
      restoredBackup[0] = [];
      return restoredBackup;
    }
    const backup2 = [[], selectionsBackupVersion];
    for (const serializedVariables in stringsHash) {
      backup2[0].push([serializedVariables, stringsHash[serializedVariables]]);
    }
    return restoredBackup = backup2;
  }
  function getVariableAlias(key, variables, variableTypes) {
    return key + "_" + getSerializedVariablesId(variableTypes) + "_" + getSerializedVariablesId(variables);
  }
  function getSelection({
    key,
    prevSelection,
    args,
    argTypes,
    type,
    unions
  }) {
    let alias;
    let cacheKey = key + "";
    if (args && argTypes) {
      alias = getVariableAlias(key, args, argTypes);
      cacheKey = alias;
    }
    if (prevSelection) {
      cacheKey = prevSelection.pathString + "." + cacheKey;
    }
    if (unions == null ? void 0 : unions.length) {
      cacheKey += ";" + unions.join(";");
    }
    let selection = selectionCache.get(cacheKey);
    if (selection == null) {
      selection = new Selection({
        key,
        prevSelection,
        args,
        argTypes,
        alias,
        type,
        unions,
        id: ++uniqueSelectionId
      });
      selectionCache.set(cacheKey, selection);
    } else if (args) {
      selection.args = args;
    }
    return selection;
  }
  return {
    getSelection,
    restore,
    backup
  };
}

export { createSelectionManager, separateSelectionTypes };
